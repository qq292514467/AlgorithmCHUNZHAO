/* 思路一：使用三指针，动态规划（先排序，再存入） */
/* 找出丑数之间的规律：
        一个丑数必然可以写为 A0 * A1 * ..... * A(n-1) * An，其中A∈[2, 3, 5]。
        那么这个丑数也可以写为 (A0 * A1 * ..... * A(n-1)) * An, 而(A0 * A1 * ..... * A(n-1))也是个丑数，且An∈[2, 3, 5]，
        所以一个丑数乘以2，3，5之后，一定还是一个丑数。
所以创建三个指针，分别对应从最小的丑数开始依次乘以2、3、5后得到的新丑数，
由于不同丑数乘以2、3、5可能会有相同结果，如6=2*3，即有重复项，需要去重；
又因为从最小丑数开始乘以2、3、5，会存在大小区别，但丑数序列需要按照大小排序，
因此从最小的丑数乘以2、3、5开始，就需要对结果进行排序比较，最小的才可以按照顺序存入当前下标位置中
 */
/* 1、创建三个指针，分别对应乘以三个质数的丑数序列
2、创建res，即丑数数组，将丑数1填入
3、创建循环，结束条件为第n个丑数不为空，即下标n-1处不为空
        每次循环，创建r2,r3,r5存储i2,i3,i5指针对应的丑数序列的结果
        调用Math.min()方法求出三个结果中最小的，赋个变量next，并存入数组res中
        使用三个if判断语句用来去重，避免类似[1,2,...6,6...]这种情况
            该情况是由于i2 = 3，i3 = 2，即上一轮循环只判断了r2,r3中的一个结果导致的
4、结束循环，返回res中下标为n-1的元素，即第n个丑数 */
var nthUglyNumber = function (n) {
    if (!n) { return 0; }
    let i2 = 0, i3 = 0, i5 = 0;
    let res = [1];
    while (!res[n - 1]) {
        let r2 = res[i2] * 2;
        let r3 = res[i3] * 3;
        let r5 = res[i5] * 5;
        let next = Math.min(Math.min(r2, r3), r5);
        res.push(next);
        if (next == r2) { i2++; }
        if (next == r3) { i3++; }
        if (next == r5) { i5++; }
    }
    return res[n - 1];
};

/* 思路二：小顶堆
前提依旧需要了解丑数的规律，相较于动态规划使用三指针的方法，小顶堆是先存入，再排序 */
/* 1、创建小顶堆
2、创建循环，
    将每次三个序列中的结果存入小顶堆
    将堆内最小的元素，即堆顶的元素取出，作为当前的丑数，赋给变量 ，存入数组中
    为了去重，创建内循环，条件为堆非空，且堆顶元素与当前丑数相等，
            若相等，也将其取出
3、循环结束，返回第n个丑数 */